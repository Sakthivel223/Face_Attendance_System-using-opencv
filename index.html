<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Ultra Low-Latency Face Recognition</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        video {
            width: 100%;
            max-width: 640px;
            height: auto;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #f0f0f0;
        }
        .video-container {
            position: relative;
            margin: 0 auto;
        }
        .overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0,0,0,0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 14px;
        }
        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px 10px 0;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }
        .success {
            background-color: #dff0d8;
            color: #3c763d;
        }
        .error {
            background-color: #f2dede;
            color: #a94442;
        }
        .warning {
            background-color: #fcf8e3;
            color: #8a6d3b;
        }
        .stats {
            font-family: monospace;
            font-size: 14px;
            margin-top: 10px;
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>Ultra Low-Latency Face Recognition</h1>
    <div id="status"></div>
    <div class="video-container">
        <video id="video" autoplay playsinline muted></video>
        <div class="overlay" id="latency">Latency: --</div>
    </div>
    <div class="controls">
        <button id="startButton">Start Camera</button>
        <button id="stopButton" disabled>Stop Camera</button>
        <button id="fullScreenButton">Full Screen</button>
    </div>
    <div class="stats" id="stats"></div>

    <script>
        const video = document.getElementById('video');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const fullScreenButton = document.getElementById('fullScreenButton');
        const statusDiv = document.getElementById('status');
        const statsDiv = document.getElementById('stats');
        const latencyDiv = document.getElementById('latency');
        let pc = null;
        let statsInterval = null;
        let frameCounter = 0;
        let lastFrameTime = 0;
        let latencyValues = [];

        // Set video low-latency properties
        video.setAttribute('playsinline', '');
        video.setAttribute('muted', '');
        
        // Enable hardware acceleration if available
        video.style.transform = 'translateZ(0)';
        video.style.backfaceVisibility = 'hidden';

        function setStatus(message, type = 'success') {
            statusDiv.textContent = message;
            statusDiv.className = type;
        }

        // Track video frame callback for performance monitoring
        function frameCallback(now, metadata) {
            frameCounter++;
            
            // Calculate FPS
            if (lastFrameTime) {
                const frameDelay = now - lastFrameTime;
                const frameLatency = metadata.presentationTime ? (now - metadata.presentationTime) : 0;
                
                // Track latency for averaging (last 10 frames)
                if (frameLatency > 0) {
                    latencyValues.push(frameLatency);
                    if (latencyValues.length > 10) latencyValues.shift();
                    
                    // Calculate average latency
                    const avgLatency = latencyValues.reduce((a, b) => a + b, 0) / latencyValues.length;
                    latencyDiv.textContent = `Latency: ${avgLatency.toFixed(1)}ms`;
                    
                    // Highlight high latency
                    if (avgLatency < 100) {
                        latencyDiv.style.backgroundColor = 'rgba(0,128,0,0.5)';
                    } else if (avgLatency < 300) {
                        latencyDiv.style.backgroundColor = 'rgba(255,165,0,0.5)';
                    } else {
                        latencyDiv.style.backgroundColor = 'rgba(255,0,0,0.5)';
                    }
                }
            }
            
            lastFrameTime = now;
            
            // Request next frame
            if (video.readyState >= 2) {
                video.requestVideoFrameCallback(frameCallback);
            }
        }

        async function getStats() {
            if (!pc) return;
            
            try {
                const stats = await pc.getStats();
                let videoStats = {};
                let connectionStats = {};
                
                stats.forEach(report => {
                    if (report.type === 'inbound-rtp' && report.kind === 'video') {
                        videoStats = {
                            jitter: report.jitter ? (report.jitter * 1000).toFixed(2) + ' ms' : 'N/A',
                            packetsLost: report.packetsLost || 0,
                            framesDecoded: report.framesDecoded || 0,
                            framesDropped: report.framesDropped || 0,
                            frameHeight: report.frameHeight || 0,
                            frameWidth: report.frameWidth || 0,
                            fps: report.framesPerSecond ? report.framesPerSecond.toFixed(1) : 'N/A',
                            bytesReceived: report.bytesReceived ? (report.bytesReceived / 1024).toFixed(0) + ' KB' : '0 KB'
                        };
                    }
                    
                    if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                        connectionStats = {
                            currentRoundTripTime: report.currentRoundTripTime ? (report.currentRoundTripTime * 1000).toFixed(2) + ' ms' : 'N/A',
                            totalRoundTripTime: report.totalRoundTripTime ? (report.totalRoundTripTime * 1000).toFixed(2) + ' ms' : 'N/A',
                        };
                    }
                });
                
                statsDiv.innerHTML = `<b>Video Stats:</b> ${videoStats.frameWidth}x${videoStats.frameHeight} @ ${videoStats.fps} FPS | Jitter: ${videoStats.jitter} | RTT: ${connectionStats.currentRoundTripTime || 'N/A'} | Lost Packets: ${videoStats.packetsLost} | Data: ${videoStats.bytesReceived}`;
            } catch (e) {
                console.error('Could not get stats:', e);
            }
        }

        async function start() {
            try {
                setStatus('Connecting to server...', 'warning');
                startButton.disabled = true;
                
                // Create peer connection with low-latency configuration
                pc = new RTCPeerConnection({
                    sdpSemantics: 'unified-plan',
                    iceCandidatePoolSize: 10,
                    iceTransportPolicy: 'all',
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require'
                });

                // Debug ICE connection state changes
                pc.oniceconnectionstatechange = () => {
                    console.log('ICE connection state:', pc.iceConnectionState);
                    if (pc.iceConnectionState === 'failed') {
                        setStatus('ICE connection failed. Try refreshing the page.', 'error');
                    } else if (pc.iceConnectionState === 'connected') {
                        console.log('ICE connected!');
                    }
                };

                // Debug connection state changes
                pc.onconnectionstatechange = () => {
                    console.log('Connection state:', pc.connectionState);
                    if (pc.connectionState === 'connected') {
                        stopButton.disabled = false;
                        setStatus('Connected! Streaming video with face recognition.', 'success');
                        
                        // Start stats collection
                        if (statsInterval) clearInterval(statsInterval);
                        statsInterval = setInterval(getStats, 1000);
                        
                        // Start frame callback for performance tracking if supported
                        if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
                            video.requestVideoFrameCallback(frameCallback);
                        }
                    } else if (pc.connectionState === 'disconnected' || 
                               pc.connectionState === 'failed' || 
                               pc.connectionState === 'closed') {
                        if (statsInterval) {
                            clearInterval(statsInterval);
                            statsInterval = null;
                        }
                    }
                };

                // Handle incoming tracks with low-latency options
                pc.ontrack = (event) => {
                    console.log('Track received:', event.track.kind);
                    if (event.track.kind === 'video') {
                        console.log('Video track received, streams:', event.streams.length);
                        if (event.streams && event.streams[0]) {
                            video.srcObject = event.streams[0];
                            
                            // Low latency settings
                            video.load();
                            
                            // Play with catch for mobile devices
                            video.play().catch(e => {
                                console.error('Error playing video:', e);
                                // Try again with user interaction
                                setStatus('Click/tap on the video area to start playback', 'warning');
                                video.addEventListener('click', () => {
                                    video.play().catch(err => console.error('Still cannot play:', err));
                                }, { once: true });
                            });
                            
                            // Reduce latency by setting minimal latency mode
                            if (video.style.webkitBackfaceVisibility !== undefined) {
                                // Force GPU acceleration
                                video.style.webkitBackfaceVisibility = 'hidden';
                            }
                            
                            if ('setLatencyHint' in video.playbackRate.constructor.prototype) {
                                video.playbackRate.setLatencyHint('interactive');
                                console.log("Set video latency hint to interactive");
                            }
                            
                            // Additional low-latency features for Chrome
                            if (video.mozDecodedFrames === undefined) { // Not Firefox
                                video.playsInline = true;
                                video.autoplay = true;
                                video.disablePictureInPicture = true;
                                video.disableRemotePlayback = true;
                            }
                        } else {
                            console.error('No media stream available in track event');
                            setStatus('Connected, but no video stream available.', 'warning');
                        }
                    }
                };

                // Create offer with low-latency preferences
                const offerOptions = {
                    offerToReceiveVideo: true,
                    offerToReceiveAudio: false,
                    voiceActivityDetection: false
                };
                
                const offer = await pc.createOffer(offerOptions);
                
                // Modify SDP for lower latency
                let sdp = offer.sdp;
                // Set max packet size for lower latency
                sdp = sdp.replace('a=max-message-size:262144', 'a=max-message-size:65536');
                // Prioritize faster codecs
                if (sdp.includes('VP8')) {
                    sdp = sdp.replace(/m=video \d+ UDP\/TLS\/RTP\/SAVPF ([\d ]+)/, (match, codecList) => {
                        const codecs = codecList.split(' ');
                        const vp8Index = codecs.findIndex((codec, i) => {
                            return sdp.includes(`a=rtpmap:${codec} VP8`);
                        });
                        if (vp8Index > 0) {
                            // Move VP8 to the front for higher priority
                            const vp8Codec = codecs[vp8Index];
                            codecs.splice(vp8Index, 1);
                            codecs.unshift(vp8Codec);
                        }
                        return `m=video 9 UDP/TLS/RTP/SAVPF ${codecs.join(' ')}`;
                    });
                }
                // Set bandwidth limitation
                if (!sdp.includes('b=AS:')) {
                    sdp = sdp.replace(/c=IN IP4.*\r\n/g, 'c=IN IP4 0.0.0.0\r\nb=AS:2000\r\n');
                }
                
                const modifiedOffer = new RTCSessionDescription({
                    type: offer.type,
                    sdp: sdp
                });
                
                await pc.setLocalDescription(modifiedOffer);

                console.log('Sending offer to server...');
                const response = await fetch('/offer', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        sdp: pc.localDescription.sdp,
                        type: pc.localDescription.type
                    })
                });

                if (!response.ok) {
                    throw new Error(`Server responded with ${response.status}: ${response.statusText}`);
                }

                const answer = await response.json();
                console.log('Received answer from server');
                await pc.setRemoteDescription(new RTCSessionDescription(answer));
                console.log('Set remote description');
                
            } catch (e) {
                setStatus(`Error: ${e.message}`, 'error');
                console.error('Error starting video:', e);
                startButton.disabled = false;
            }
        }

        async function stop() {
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }
            
            // Reset latency display
            latencyDiv.textContent = 'Latency: --';
            latencyDiv.style.backgroundColor = 'rgba(0,0,0,0.5)';
            latencyValues = [];
            
            if (pc) {
                pc.close();
                pc = null;
            }
            
            if (video.srcObject) {
                const tracks = video.srcObject.getTracks();
                tracks.forEach(track => track.stop());
                video.srcObject = null;
            }
            
            setStatus('Camera stopped.', 'warning');
            startButton.disabled = false;
            stopButton.disabled = true;
            statsDiv.textContent = '';
        }
        
        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                if (video.requestFullscreen) {
                    video.requestFullscreen();
                } else if (video.webkitRequestFullscreen) {
                    video.webkitRequestFullscreen();
                } else if (video.msRequestFullscreen) {
                    video.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        startButton.addEventListener('click', start);
        stopButton.addEventListener('click', stop);
        fullScreenButton.addEventListener('click', toggleFullScreen);
        
        // Auto-restart on errors after a delay
        video.addEventListener('error', (e) => {
            console.error('Video error:', e);
            setStatus('Video error detected. Attempting to reconnect...', 'error');
            setTimeout(() => {
                if (pc && pc.connectionState === 'connected') {
                    // Try to recover without full restart
                    if (video.srcObject) {
                        video.srcObject.getTracks().forEach(track => {
                            if (track.readyState !== 'live') {
                                console.log('Track is not live, requesting restart');
                                stop();
                                setTimeout(start, 1000);
                            }
                        });
                    }
                }
            }, 3000);
        });

        // Clean up when page is closed
        window.onbeforeunload = function() {
            if (statsInterval) {
                clearInterval(statsInterval);
            }
            if (pc) {
                pc.close();
                pc = null;
            }
        };
    </script>
</body>
</html>